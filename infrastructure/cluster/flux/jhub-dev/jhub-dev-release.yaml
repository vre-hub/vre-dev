apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: jhub-dev
  namespace: jhub-dev
spec:
  releaseName: jhub-dev
  interval: 1m
  chart:
    spec:
      sourceRef:
        kind: HelmRepository
        name: jhub-dev
        namespace: jhub-dev
      chart: jupyterhub
      interval: 1m
      version: 3.3.7
  valuesFrom:
    - kind: Secret
      name: jhub-dev-iam-secrets
      valuesKey: client_id
      targetPath: hub.config.RucioAuthenticator.client_id
    - kind: Secret
      name: jhub-dev-iam-secrets
      valuesKey: client_secret
      targetPath: hub.config.RucioAuthenticator.client_secret
    - kind: Secret
      name: jhub-dev-db
      valuesKey: dbfullstring
      targetPath: hub.db.url
    - kind: Secret
      name: jupyterhub-auth-state
      valuesKey: JUPYTERHUB_CRYPT_KEY
      targetPath: hub.extraEnv.JUPYTERHUB_CRYPT_KEY
    - kind: Secret
      name: jhub-dev-zenodo-oauth-secrets
      valuesKey: client_id
      targetPath: hub.extraEnv.ZENODO_CLIENT_ID
    - kind: Secret
      name: jhub-dev-zenodo-oauth-secrets
      valuesKey: client_secret
      targetPath: hub.extraEnv.ZENODO_CLIENT_SECRET
  values:
    proxy:
      service:
        
      service:
        type: ClusterIP
      networkPolicy:
        enabled: false
      db:
        type: postgres # secret dbconnect string set in main-helm.tf
      extraEnv:
        ZENODO_AUTHORIZE_URL: https://sandbox.zenodo.org/oauth/authorize
        ZENODO_TOKEN_URL: https://sandbox.zenodo.org/oauth/token
        ZENODO_SCOPES: "deposit:write deposit:actions"
        ZENODO_SANDBOX: "true"
      config:
        JupyterHub:
          authenticator_class: generic-oauth
        RucioAuthenticator:
        # GenericOAuthenticator:
          #client_id: "" # set through secret
          #client_secret: "" # set through secret
          authorize_url: https://iam-escape.cloud.cnaf.infn.it/authorize
          token_url: https://iam-escape.cloud.cnaf.infn.it/token
          userdata_url: https://iam-escape.cloud.cnaf.infn.it/userinfo
          username_key: preferred_username
          enable_auth_state: true
          allow_all: true
          scope:
            - openid
            - profile
            - email
      services:
        zenodo-auth:
          # Use the hub service DNS so the proxy (separate pod) can reach the managed service
          url: http://jhub-dev-hub:9995
          command:
            - bash
            - -lc
            - |
              python3 - <<'PY'
              import os, secrets, time, json, pathlib, requests
              from urllib.parse import urlencode
              from tornado import web, ioloop, httpserver
              from jupyterhub.services.auth import HubAuthenticated

              ZENDO_AUTHORIZE_DEFAULT = "https://sandbox.zenodo.org/oauth/authorize"
              ZENDO_TOKEN_DEFAULT = "https://sandbox.zenodo.org/oauth/token"
              ZENODO_AUTHORIZE_URL = os.environ.get("ZENODO_AUTHORIZE_URL", ZENDO_AUTHORIZE_DEFAULT)
              ZENODO_TOKEN_URL = os.environ.get("ZENODO_TOKEN_URL", ZENDO_TOKEN_DEFAULT)
              ZENODO_SCOPES = os.environ.get("ZENODO_SCOPES", "deposit:write deposit:actions")
              ZENODO_SANDBOX = os.environ.get("ZENODO_SANDBOX", "true")
              TOKENS_DIR = os.environ.get("ZENODO_TOKENS_DIR", "/srv/jupyterhub/zenodo-tokens")

              class LoginHandler(HubAuthenticated, web.RequestHandler):
                  async def get(self):
                      user = await self.get_current_user()
                      if not user:
                          raise web.HTTPError(403)
                      state = secrets.token_urlsafe(24)
                      self.set_secure_cookie("zen_state", state, httponly=True, secure=True, samesite="lax")
                      prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/services/zenodo-auth/")
                      callback_path = prefix.rstrip("/") + "/callback"
                      redirect_uri = os.environ.get("ZENODO_REDIRECT_URI") or f"{self.request.protocol}://{self.request.host}{callback_path}"
                      params = {
                          "response_type": "code",
                          "client_id": os.environ["ZENODO_CLIENT_ID"],
                          "redirect_uri": redirect_uri,
                          "scope": ZENODO_SCOPES,
                          "state": state,
                      }
                      self.redirect(f"{ZENODO_AUTHORIZE_URL}?{urlencode(params)}")

              class CallbackHandler(HubAuthenticated, web.RequestHandler):
                  async def get(self):
                      user = await self.get_current_user()
                      if not user:
                          raise web.HTTPError(403)
                      state_cookie = self.get_secure_cookie("zen_state")
                      state_param = self.get_argument("state", "")
                      if not state_cookie or state_cookie.decode() != state_param:
                          raise web.HTTPError(400, "Invalid state")
                      code = self.get_argument("code", "")
                      prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/services/zenodo-auth/")
                      callback_path = prefix.rstrip("/") + "/callback"
                      redirect_uri = os.environ.get("ZENODO_REDIRECT_URI") or f"{self.request.protocol}://{self.request.host}{callback_path}"
                      data = {
                          "grant_type": "authorization_code",
                          "code": code,
                          "redirect_uri": redirect_uri,
                          "client_id": os.environ["ZENODO_CLIENT_ID"],
                          "client_secret": os.environ["ZENODO_CLIENT_SECRET"],
                      }
                      r = requests.post(ZENODO_TOKEN_URL, data=data, timeout=20)
                      r.raise_for_status()
                      tok = r.json()
                      access_token = tok["access_token"]
                      expires_in = int(tok.get("expires_in", 3600))
                      pathlib.Path(TOKENS_DIR).mkdir(parents=True, exist_ok=True)
                      with open(os.path.join(TOKENS_DIR, f"{user['name']}.json"), "w") as f:
                          json.dump({
                              "access_token": access_token,
                              "expires_at": int(time.time()) + expires_in,
                              "scopes": ZENODO_SCOPES,
                              "sandbox": ZENODO_SANDBOX,
                          }, f)
                      self.clear_cookie("zen_state")
                      self.redirect("/hub/home")

              def make_app():
                  prefix = os.environ.get("JUPYTERHUB_SERVICE_PREFIX", "/services/zenodo-auth/")
                  return web.Application([
                      (prefix.rstrip("/") + "/login", LoginHandler),
                      (prefix.rstrip("/") + "/callback", CallbackHandler),
                  ])

              if __name__ == "__main__":
                  app = make_app()
                  server = httpserver.HTTPServer(app)
                  # Listen on all interfaces so the proxy pod can reach the service
                  server.listen(9995, address='0.0.0.0')
                  ioloop.IOLoop.current().start()
              PY

          environment:
            ZENODO_TOKENS_DIR: /srv/jupyterhub/zenodo-tokens

      extraConfig:
        token-exchange: |
          import pprint
          import os
          import warnings
          import requests
          from oauthenticator.generic import GenericOAuthenticator

          class RucioAuthenticator(GenericOAuthenticator):
              def __init__(self, **kwargs):
                  super().__init__(**kwargs)
                  self.enable_auth_state = True

              def exchange_token(self, token):
                  params = {
                      'client_id': self.client_id,
                      'client_secret': self.client_secret,
                      'grant_type': 'urn:ietf:params:oauth:grant-type:token-exchange',
                      'subject_token_type': 'urn:ietf:params:oauth:token-type:access_token',
                      'subject_token': token,
                      'scope': 'openid profile',
                      'audience': 'rucio'
                  }
                  response = requests.post(self.token_url, data=params)
                  print("EXCHANGE TOKEN RESPONSE")
                  print(response.json())
                  rucio_token = response.json().get('access_token')
                  return rucio_token

              async def pre_spawn_start(self, user, spawner):
                  auth_state = await user.get_auth_state() or {}
                  print("PRE SPAWN START - auth_state")
                  pprint.pprint(auth_state)
                  try:
                      access = auth_state.get('access_token')
                      if access:
                          spawner.environment['RUCIO_ACCESS_TOKEN'] = self.exchange_token(access)
                          spawner.environment['EOS_ACCESS_TOKEN'] = access
                  except Exception as e:
                      print(f"Rucio token injection error: {e}")

                  try:
                      import json
                      tokens_dir = os.environ.get('ZENODO_TOKENS_DIR', '/srv/jupyterhub/zenodo-tokens')
                      token_path = os.path.join(tokens_dir, f"{user.name}.json")
                      zen_token = None
                      if os.path.exists(token_path):
                          with open(token_path) as f:
                              data = json.load(f)
                              zen_token = data.get('access_token')
                              if 'sandbox' in data:
                                  spawner.environment['ZENODO_SANDBOX'] = str(data.get('sandbox')).lower()
                      if not zen_token and isinstance(auth_state, dict):
                          zen = auth_state.get('zenodo', {})
                          zen_token = zen.get('access_token')
                      if zen_token:
                          spawner.environment['ZENODO_API_KEY'] = zen_token
                          spawner.environment.setdefault('ZENODO_SANDBOX', os.environ.get('ZENODO_SANDBOX', 'true'))
                  except Exception as e:
                      print(f"ZENODO token injection error: {e}")

          c.JupyterHub.authenticator_class = RucioAuthenticator

          crypt_key = os.getenv("JUPYTERHUB_CRYPT_KEY")
          if crypt_key:
              c.CryptKeeper.keys = [crypt_key]
          else:
              warnings.warn(
                  "Need JUPYTERHUB_CRYPT_KEY env for persistent auth_state.\n"
                  "    export JUPYTERHUB_CRYPT_KEY=$(openssl rand -hex 32)"
              )
              c.CryptKeeper.keys = [os.urandom(32)]

          # enable authentication state
          c.GenericOAuthenticator.enable_auth_state = True

    singleuser:
      defaultUrl: "/lab"
      # The liefcycle hooks are used to create the Rucio configuration file,
      # and the token file by copying the REFRESH_TOKEN from the environment variable to the token file.
      lifecycleHooks:
        postStart:
          exec:
            command:
              - "sh"
              - "-c"
              - >
                mkdir -p /certs /tmp;
                echo -n $RUCIO_ACCESS_TOKEN > /tmp/rucio_oauth.token;
                echo -n "oauth2:${EOS_ACCESS_TOKEN}:iam-escape.cloud.cnaf.infn.it/userinfo" > /tmp/eos_oauth.token;
                chmod 0600 /tmp/eos_oauth.token;
                mkdir -p /opt/rucio/etc;
                echo "[client]" >> /opt/rucio/etc/rucio.cfg;
                echo "rucio_host = https://vre-rucio.cern.ch" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_host = https://vre-rucio-auth.cern.ch" >> /opt/rucio/etc/rucio.cfg;
                echo "ca_cert = /certs/rucio_ca.pem" >> /opt/rucio/etc/rucio.cfg;
                echo "account = $JUPYTERHUB_USER" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_type = oidc" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_audience = rucio" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_polling = true" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_issuer = escape" >> /opt/rucio/etc/rucio.cfg;
                echo "oidc_scope = openid profile offline_access" >> /opt/rucio/etc/rucio.cfg;
                echo "auth_token_file_path = /tmp/rucio_oauth.token" >> /opt/rucio/etc/rucio.cfg;

      networkPolicy:
        enabled: false
      storage:
        type: static
        static:
          pvcName: jhub-dev-pvc 
        extraVolumes:
          - name: cvmfs-vre-dev
            persistentVolumeClaim:
              claimName: cvmfs-pvc
          - name: eospilot-eulake-dev 
            hostPath:
              path: /var/eos/pilot
        extraVolumeMounts:
          - name: cvmfs-vre-dev
            mountPath: /cvmfs
            # CVMFS automount volumes must be mounted with HostToContainer mount propagation.
            mountPropagation: HostToContainer
          - name: eospilot-eulake-dev 
            mountPath: /eos/eulake
            mountPropagation: HostToContainer
            readOnly: true 
      image:
        # name: quay.io/jupyter/scipy-notebook
        # tag: python-3.11.8
        # name: jupyter/scipy-notebook
        # tag: python-3.10.11
        name: ghcr.io/vre-hub/vre-singleuser-py311
        # tag: latest
        tag: sha-281055c
        pullPolicy: Always
      profileList:
        - display_name: "Default environment"
          description: "Default VRE environment."
          default: true
        - display_name: "Python 3.11 environment"
          description: "quay.io/jupyter/scipy-notebook:python-3.11 image"
          kubespawner_override:
            image: quay.io/jupyter/scipy-notebook:python-3.11.10
        - display_name: "Python 3.10 environment"
          description: "quay.io/jupyter/scipy-notebook:python-3.10.11 image"
          kubespawner_override:
            image: jupyter/scipy-notebook:python-3.10.11
        - display_name: "Zenodo Jupyterlab dev env"
          description: "All in the tittle"
          kubespawner_override:
            image: ghcr.io/vre-hub/zenodo-jghcr.io/vre-hub/zenodo-jupyterlab-extension:refactor_extension
        # - display_name: "VRE and rucio extension integration"
        #   description: "python3.11 and Rucio extension integration "
        #   kubespawner_override:
        #     image: ghcr.io/vre-hub/vre-singleuser-py311:latest
        # - display_name: "REANA dev environment"
        #   description: "For testing purposes"
        #   kubespawner_override:
        #     image:  ghcr.io/vre-hub/vre-singleuser-reana-dev:latest
        - display_name: "VRE DEV environment"
          description: "vre-dev image"
          kubespawner_override:
            image: ghcr.io/vre-hub/vre-singleuser-dev:latest
    
      # nodeSelector: 
      #   jupyter: singleuser
      # extraTolerations:
      #   - key: jupyter
      #     operator: Equal
      #     value: singleuser
      #     effect: NoSchedule
      # memory:
      #   limit: 3.5G #4G
      #   guarantee: 3G #2G

      cmd: null
      extraEnv:
        RUCIO_MODE: "replica"
        RUCIO_WILDCARD_ENABLED: "1"
        RUCIO_BASE_URL: "https://vre-rucio.cern.ch"
        RUCIO_AUTH_URL: "https://vre-rucio-auth.cern.ch"
        RUCIO_WEBUI_URL: "https://vre-rucio-ui.cern.ch"
        RUCIO_DISPLAY_NAME: "RUCIO - CERN VRE"
        RUCIO_NAME: "vre-rucio.cern.ch"
        RUCIO_SITE_NAME: "CERN"
        RUCIO_OIDC_AUTH: "env"
        RUCIO_OIDC_ENV_NAME: "RUCIO_ACCESS_TOKEN"
        RUCIO_DEFAULT_AUTH_TYPE: "oidc"
        RUCIO_OAUTH_ID: "rucio"
        RUCIO_DEFAULT_INSTANCE: "vre-rucio.cern.ch"
        RUCIO_DESTINATION_RSE: "CERN-EOSPILOT"
        RUCIO_RSE_MOUNT_PATH: "/eos/eulake-dev"
        RUCIO_PATH_BEGINS_AT: "5"  # eos/pilot/eulake/escape/dev -> /eos/eulake-dev
        RUCIO_CA_CERT: "/certs/rucio_ca.pem"
        OAUTH2_TOKEN: "FILE:/tmp/eos_oauth.token"

    ingress:
      enabled: true
      ingressClassName: nginx
      annotations:
        cert-manager.io/cluster-issuer: "letsencrypt" # this issues a certificate for the domain through cert-manager automatically
      hosts:
        - jhub-vre-dev.cern.ch
      tls:
        - hosts:
            - jhub-vre-dev.cern.ch
          secretName: cert-manager-tls-ingress-secret-jhub-dev


